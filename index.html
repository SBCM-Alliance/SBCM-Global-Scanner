<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SBCM FIELD SCANNER v3.3</title>
    
    <!-- Fonts & Map -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root {
            --bg: #050505; --panel: #111; --text: #e0e0e0;
            --accent: #00ff41; --warn: #ff0055; --sub: #666; --cyan: #00ffff;
        }
        * { box-sizing: border-box; }
        
        body { 
            margin: 0; background: var(--bg); color: var(--text); 
            font-family: 'JetBrains Mono', monospace, sans-serif;
            padding: 20px; line-height: 1.5; min-height: 100vh;
        }
        
        .container { max-width: 600px; margin: 0 auto; padding-bottom: 80px; }
        
        /* HEADER */
        header { text-align: center; margin-bottom: 20px; }
        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 2px; color: #fff; }
        .subtitle { font-size: 0.7rem; color: var(--sub); }

        /* KEYPAD */
        .keypad {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
            margin-bottom: 15px;
        }
        .key-btn {
            aspect-ratio: 1.3; background: #000; border: 1px solid #333; color: #fff;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; border-radius: 4px; transition: 0.1s;
        }
        .key-btn:active { background: #222; border-color: var(--cyan); }
        .key-label { font-size: 0.85rem; font-weight: bold; }
        .key-sub { font-size: 0.6rem; color: #666; }

        /* MANUAL INPUT */
        .hidden { display: none; }
        #manual-input { display: flex; gap: 5px; margin-bottom: 15px; }
        input { flex: 1; background: #000; border: 1px solid #333; color: #fff; padding: 10px; font-family: inherit; }
        button { background: var(--text); color: #000; border: none; padding: 0 15px; font-weight: bold; cursor: pointer; }

        /* MAP VIEWER */
        #map-viewer {
            display: none; position: relative;
            width: 100%; height: 500px;
            border: 1px solid var(--cyan);
            border-radius: 8px; overflow: hidden; margin-top: 20px;
        }
        #map { width: 100%; height: 100%; background: #222; z-index: 1; }
        #field-canvas { position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none; }

        /* ANALYSIS BOX */
        #analysis-box {
            position: absolute; bottom: 0; left: 0; right: 0; z-index: 10;
            background: rgba(0,0,0,0.9); border-top: 2px solid var(--cyan);
            padding: 15px; font-size: 0.8rem;
            transform: translateY(100%); transition: transform 0.3s;
        }
        #analysis-box.visible { transform: translateY(0); }
        
        .analysis-title { color: var(--sub); font-size: 0.7rem; margin-bottom: 5px; display: flex; justify-content: space-between; }
        .analysis-text { color: #fff; line-height: 1.4; margin-bottom: 10px; }
        .analysis-tag { display: inline-block; padding: 2px 6px; border-radius: 2px; font-weight: bold; font-size: 0.7rem; color: #000; }
        
        .tag-safe { background: var(--accent); }
        .tag-warn { background: orange; }
        .tag-danger { background: var(--warn); color: #fff; }

        /* STATUS OVERLAY */
        .map-status-bar {
            position: absolute; top: 10px; left: 10px; right: 10px; z-index: 3;
            display: flex; justify-content: space-between; pointer-events: none;
        }
        .status-badge {
            background: rgba(0,0,0,0.8); padding: 5px 10px; border: 1px solid #333;
            font-size: 0.7rem; color: var(--cyan); backdrop-filter: blur(2px);
        }
        
        /* LOADER */
        #mini-loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 4; display: none; flex-direction: column; align-items: center;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 8px;
        }
        .spinner {
            width: 24px; height: 24px; border: 2px solid #333; border-top: 2px solid var(--cyan);
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 5px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1>SBCM FIELD SCANNER</h1>
            <div class="subtitle">REAL-TIME DYNAMIC ANALYSIS</div>
        </header>

        <!-- KEYPAD -->
        <div class="keypad">
            <div class="key-btn" onclick="jumpTo('è±Šå³¶åŒº')"><span class="key-label">è±Šå³¶åŒº</span><span class="key-sub">TKYO</span></div>
            <div class="key-btn" onclick="jumpTo('æ¸¯åŒº')"><span class="key-label">æ¸¯åŒº</span><span class="key-sub">TKYO</span></div>
            <div class="key-btn" onclick="jumpTo('æŸå¸‚')"><span class="key-label">æŸå¸‚</span><span class="key-sub">CHIBA</span></div>
            
            <div class="key-btn" onclick="jumpTo('äº¬éƒ½å¸‚')"><span class="key-label">äº¬éƒ½å¸‚</span><span class="key-sub">KYOTO</span></div>
            <div class="key-btn" onclick="jumpTo('å¤§é˜ªå¸‚')"><span class="key-label">å¤§é˜ªå¸‚</span><span class="key-sub">OSAKA</span></div>
            <div class="key-btn" onclick="jumpTo('ç¥æˆ¸å¸‚')"><span class="key-label">ç¥æˆ¸å¸‚</span><span class="key-sub">HYOGO</span></div>
            
            <div class="key-btn" onclick="jumpTo('ç¦å²¡å¸‚')"><span class="key-label">ç¦å²¡å¸‚</span><span class="key-sub">FUK</span></div>
            <div class="key-btn" onclick="jumpTo('å¤•å¼µå¸‚')"><span class="key-label">å¤•å¼µå¸‚</span><span class="key-sub">HKD</span></div>
            <div class="key-btn" onclick="jumpTo('ç™½ç³ ç”º')"><span class="key-label">ç™½ç³ ç”º</span><span class="key-sub">HKD</span></div>
        </div>

        <!-- MANUAL -->
        <div style="text-align:center; margin-bottom:10px;">
            <span onclick="document.getElementById('manual-input').classList.toggle('hidden')" style="cursor:pointer; color:#666; font-size:0.7rem;">â–¼ MANUAL SEARCH</span>
        </div>
        <div id="manual-input" class="hidden">
            <input type="text" id="city-in" placeholder="City Name">
            <button onclick="jumpTo(document.getElementById('city-in').value)">GO</button>
        </div>

        <!-- MAP -->
        <div id="map-viewer">
            <div id="map"></div>
            <canvas id="field-canvas"></canvas>
            
            <!-- Overlays -->
            <div class="map-status-bar">
                <div class="status-badge" id="live-coords">READY</div>
            </div>
            
            <div id="mini-loader">
                <div class="spinner"></div>
                <div style="font-size:0.7rem; color:#fff;">FETCHING DATA...</div>
            </div>

            <!-- ANALYSIS POPUP -->
            <div id="analysis-box">
                <div class="analysis-title">
                    <span>AI AUDITOR LOG</span>
                    <span id="ai-score">SCORE: ---</span>
                </div>
                <div id="ai-text" class="analysis-text">
                    Scanning field data...
                </div>
                <div id="ai-tag" class="analysis-tag tag-safe">ANALYZING</div>
            </div>
        </div>
    </div>

    <script>
        const OVERPASS_API = "https://overpass-api.de/api/interpreter";
        let map, canvas, ctx;
        let osmElements = [];
        let isFetching = false;

        window.onload = () => {
            map = L.map('map', { zoomControl: false }).setView([35.6895, 139.6917], 13);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; CartoDB',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            canvas = document.getElementById('field-canvas');
            ctx = canvas.getContext('2d');

            map.on('moveend', onMapMove);
            map.on('zoomend', onMapMove);
            map.on('resize', resizeCanvas);
        };

        // 1. JUMP
        async function jumpTo(city) {
            if(!city) return;
            document.getElementById('map-viewer').style.display = 'block';
            map.invalidateSize(); 
            try {
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}&limit=1`;
                const res = await fetch(url);
                const data = await res.json();
                if(data.length > 0) {
                    const lat = parseFloat(data[0].lat);
                    const lon = parseFloat(data[0].lon);
                    map.setView([lat, lon], 14);
                } else { alert("City not found"); }
            } catch(e) { alert("Geo Error"); }
        }

        // 2. FETCH
        function onMapMove() {
            const zoom = map.getZoom();
            if(zoom < 13) {
                updateAnalysis("ZOOM_OUT", 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            fetchViewportData();
        }

        async function fetchViewportData() {
            if(isFetching) return;
            isFetching = true;
            document.getElementById('mini-loader').style.display = 'flex';
            document.getElementById('analysis-box').classList.remove('visible'); 

            const b = map.getBounds();
            document.getElementById('live-coords').innerText = `LAT:${b.getNorth().toFixed(2)} LON:${b.getEast().toFixed(2)}`;

            try {
                const query = `[out:json][timeout:10];(way["highway"](${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()});node(w););out skel;`;
                const res = await fetch(OVERPASS_API, { method: 'POST', body: query });
                const data = await res.json();
                osmElements = data.elements;
                
                resizeCanvas();
                drawVectorField();
                analyzeData(osmElements);

            } catch(err) { console.log("Fetch error"); } 
            finally {
                isFetching = false;
                document.getElementById('mini-loader').style.display = 'none';
            }
        }

        // 3. ANALYSIS LOGIC (AI AUDITOR) - STRICT MODE
        function analyzeData(elements) {
            let nodes = 0, ways = 0;
            elements.forEach(e => {
                if(e.type === 'node') nodes++;
                if(e.type === 'way') ways++;
            });

            // çµ¶å¯¾çš„ãªå¯†åº¦ï¼ˆè¦ç´ æ•°ï¼‰ã§è¶³åˆ‡ã‚Šã‚’è¡Œã†
            const totalDensity = nodes + ways;
            
            let type = "SAFE";
            let score = 0;

            if (totalDensity < 200) {
                // ã‚¹ã‚«ã‚¹ã‚«ã™ãã‚‹ = çµŒæ¸ˆæ´»å‹•ã»ã¼ãªã—ï¼ˆVOIDï¼‰
                type = "VOID";
                score = 999; 
            } else if (totalDensity < 800) {
                // è¦ç´ ã¯ã‚ã‚‹ãŒã€éƒ½å¸‚ã¨ã—ã¦ã¯ã‚¹ã‚«ã‚¹ã‚«ï¼ˆå±±é“ã®ã‚«ãƒ¼ãƒ–ãªã©ï¼‰
                // ä»¥å‰ã¯ã“ã“ã§Ratioè¨ˆç®—ã‚’ã—ã¦ã—ã¾ã„ã€å±±é“ãŒé«˜è©•ä¾¡ã«ãªã£ã¦ã„ãŸã€‚
                // ã“ã“ã§CRITICALã«è½ã¨ã™ã“ã¨ã§ãƒã‚°ã‚’è§£æ¶ˆã€‚
                type = "CRITICAL";
                score = 500;
            } else {
                // ã“ã“ã¾ã§æ¥ã¦åˆã‚ã¦ã€Œéƒ½å¸‚ã€ã¨ã—ã¦ã®åŠ¹ç‡ã‚’è¨ˆç®—ã™ã‚‹æ¨©åˆ©ã‚’å¾—ã‚‹
                // éƒ½å¸‚éƒ¨: äº¤å·®ç‚¹(åˆ†å²)ã‚ãŸã‚Šã®é“è·¯é•·ã‚’è¦‹ã‚‹
                score = (ways * 50) / (nodes || 1); 
                
                if(score > 30) type = "WARN";
                if(score > 60) type = "CRITICAL"; 
            }

            updateAnalysis(type, score, nodes);
        }

        function updateAnalysis(type, score, nodes) {
            const box = document.getElementById('analysis-box');
            const txt = document.getElementById('ai-text');
            const tag = document.getElementById('ai-tag');
            const sc = document.getElementById('ai-score');

            sc.innerText = `BURDEN: ${score.toFixed(1)}`;
            box.classList.add('visible');

            if (type === "ZOOM_OUT") {
                txt.innerHTML = "åºƒåŸŸã‚¹ã‚­ãƒ£ãƒ³å¾…æ©Ÿä¸­ã€‚<br>è©³ç´°åˆ†æã®ãŸã‚ã€åœ°å›³ã‚’æ‹¡å¤§ã—ã¦ãã ã•ã„ã€‚";
                tag.className = "analysis-tag"; 
                tag.style.background = "#666"; tag.innerText = "STANDBY";
                return;
            }

            if (type === "SAFE") {
                txt.innerHTML = `âœ… <b>é«˜å¯†åº¦ãƒ»è‡ªå¾‹å¾ªç’°å‹</b><br>ã‚¤ãƒ³ãƒ•ãƒ©åŠ¹ç‡ã¯æ¥µã‚ã¦è‰¯å¥½ã§ã™ã€‚å¯Œã®ãƒ™ã‚¯ãƒˆãƒ«ã¯ã‚¨ãƒªã‚¢å†…ã§è¤‡é›‘ã«å¾ªç’°ã—ã¦ãŠã‚Šã€å¤–éƒ¨ã¸ã®æ¼å‡ºã¯æœ€å°é™ã§ã™ã€‚`;
                tag.className = "analysis-tag tag-safe"; tag.innerText = "EXCELLENT";
                box.style.borderTopColor = "var(--accent)";
            } 
            else if (type === "WARN") {
                txt.innerHTML = `âš ï¸ <b>åŠ¹ç‡ä½ä¸‹ã®å…†å€™</b><br>ã‚¤ãƒ³ãƒ•ãƒ©å¯†åº¦ãŒåˆ†æ•£ã—å§‹ã‚ã¦ã„ã¾ã™ã€‚ãƒ™ã‚¯ãƒˆãƒ«ã®ä¸€éƒ¨ãŒå¹¹ç·šé“è·¯ã¸æµå‡ºã—ã€ã‚¹ãƒˆãƒ­ãƒ¼åŠ¹æœã®åˆæœŸæ®µéšãŒè¦‹ã‚‰ã‚Œã¾ã™ã€‚`;
                tag.className = "analysis-tag tag-warn"; tag.innerText = "WARNING";
                box.style.borderTopColor = "orange";
            }
            else if (type === "CRITICAL") {
                txt.innerHTML = `ğŸš¨ <b>æ§‹é€ çš„æ¬ é™¥ãƒ»é«˜è² è·</b><br>ã‚¤ãƒ³ãƒ•ãƒ©ç¶­æŒã‚³ã‚¹ãƒˆãŒé™ç•Œã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ãƒ™ã‚¯ãƒˆãƒ«ã¯ã€Œä¸€æœ¬é“ã€ã«å¸ã„å¯„ã›ã‚‰ã‚Œã€å¯ŒãŒã‚¨ãƒªã‚¢å¤–ã¸æ€¥é€Ÿã«æµå‡ºã—ã¦ã„ã¾ã™ã€‚`;
                tag.className = "analysis-tag tag-danger"; tag.innerText = "CRITICAL";
                box.style.borderTopColor = "var(--warn)";
            }
            else if (type === "VOID") {
                txt.innerHTML = `ğŸŒŒ <b>çµŒæ¸ˆç©ºç™½åœ°å¸¯</b><br>æœ‰æ„ãªçµŒæ¸ˆæ´»å‹•ï¼ˆãƒãƒ¼ãƒ‰ï¼‰ãŒæ¤œçŸ¥ã•ã‚Œã¾ã›ã‚“ã€‚å®Œå…¨ãªéç–ã€ã¾ãŸã¯è‡ªç„¶ä¿è­·åŒºã§ã™ã€‚ç¶­æŒã‚³ã‚¹ãƒˆã®ã¿ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚`;
                tag.className = "analysis-tag tag-danger"; tag.innerText = "VOID";
                box.style.borderTopColor = "#555";
            }
        }

        // 4. DRAWING
        function resizeCanvas() {
            const wrap = document.getElementById('map-viewer');
            canvas.width = wrap.clientWidth;
            canvas.height = wrap.clientHeight;
        }

        function drawVectorField() {
            if(!osmElements.length) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const gridSize = 40; 
            const cols = Math.ceil(canvas.width / gridSize);
            const rows = Math.ceil(canvas.height / gridSize);
            const grid = Array(cols).fill().map(() => Array(rows).fill(0));

            const bounds = map.getBounds();
            osmElements.forEach(el => {
                if(el.type === 'node') {
                    const p = map.latLngToContainerPoint([el.lat, el.lon]);
                    const x = Math.floor(p.x / gridSize);
                    const y = Math.floor(p.y / gridSize);
                    if(x>=0 && x<cols && y>=0 && y<rows) grid[x][y]++;
                }
            });

            for (let x = 1; x < cols - 1; x++) {
                for (let y = 1; y < rows - 1; y++) {
                    const density = grid[x][y];
                    const dx = (grid[x-1][y] - grid[x+1][y]) * 5;
                    const dy = (grid[x][y-1] - grid[x][y+1]) * 5;
                    
                    if(density < 1) {
                        ctx.fillStyle = `rgba(255, 0, 85, 0.15)`;
                        ctx.fillRect(x*gridSize, y*gridSize, gridSize, gridSize);
                    }
                    const px = x * gridSize + gridSize/2;
                    const py = y * gridSize + gridSize/2;
                    drawArrow(ctx, px, py, dx, dy);
                }
            }
        }

        function drawArrow(ctx, x, y, dx, dy) {
            const len = Math.sqrt(dx*dx + dy*dy);
            if(len < 2) return;
            const angle = Math.atan2(dy, dx);
            const size = Math.min(len, 25);

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.strokeStyle = "rgba(0, 255, 255, 0.6)";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-size/2, 0);
            ctx.lineTo(size/2, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(size/2, 0);
            ctx.lineTo(size/2-4, -3);
            ctx.lineTo(size/2-4, 3);
            ctx.fillStyle = "cyan";
            ctx.fill();
            ctx.restore();
        }
    </script>
</body>
</html>
